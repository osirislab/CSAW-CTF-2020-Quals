/*
 * not_malware.c
 *
 *      Main executable distributed to the user for analysis, and contains
 *      the checking routine to determine whether the user should receive the flag or not.
 *
 *      Final input should look something like this:
 *          softbank:475:71651660587965760966:end
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <unistd.h>

#include "goaway.h"

#define BUF_SIZE 60
#define CC_LEN 20

const char BANK_NAMES[6][9] = {
    "yeetbank",
    "peepbank",
    "heapbank",
    "softbank", // we only take CCs from softbank!
    "seatbank",
    "zorpbank"
};

static inline void win(void) {
    int c;
    FILE *file;
    file = fopen("flag.txt", "r");
    if (file) {
        while ((c = getc(file) != EOF))
            putchar(c);
        fclose(file);
    }
}


/* generate a deterministic value given a seed number */
uint64_t seed(int seedint) {
    srand(seedint);
    return rand();
}


/* anti-analysis calls */
void go_away(void) {
    //hypervisors_are_scary();
    no_sneaky_loading();
    stop_intruders();
}


int main(void)
{
    int ind, c;
    int seeder, incrementer, indexer;
    char our_bank[8];

    /* repeated calls to go_away is unnecessary but annoying to the user */
    go_away();

    printf("\n\tDISCLAIMER: To be perfectly frank, I do some malware-y things\n"
           "\tbut that doesn't mean I'm malware, I promise!!\n\n");
    printf("Okay now with that out of the way, what's your credit card number?\n>> ");

    /* read credit card from STDIN */
    char input[BUF_SIZE];
    fgets(input, sizeof(input), stdin);

    /* This is actually a useless check meant to waste a symbolic executors time, since fgets truncates the length. */
    if (strlen(input) > BUF_SIZE) {
        printf("Well this was unnecessary.\n");
        exit(EXIT_FAILURE);
    }

    /* selects the bank we only trust */
    ind = 0;
    ind = ind + 256;
    ind = (ind >> 2) >> 2;
    ind = pow(ind, 0.5) - 1;

    /* grab first 8 chars as slice of string */
    c = 0;
    while (c < 8) {
        our_bank[c] = input[c];
        c++;
    }
    our_bank[c] = '\0';

    /* check if our bank is correct from slice */
    if (strncmp(our_bank, BANK_NAMES + ind, 8) != 0) {
        exit(EXIT_FAILURE);
    }

    /* check if we have a seperator after bank name */
    if (input[8] != ':') {
        printf("Get out.\n");
        exit(EXIT_FAILURE);
    }

    /* parse first number in input as `seed()` input */
    seeder = input[9] - '0';

    /* parse second number as increment counter to `seed()` input */
    incrementer = input[10] - '0';

    /* value to index from each generated number to recover the CC */
    indexer = input[11] - '0';

    /* check if we have a seperator after two "index nums" */
    if (input[12] != ':') {
        printf("Get out.\n");
        exit(EXIT_FAILURE);
    }

    /* parse out the CC number by creating a determinstic num from the seeder, indexing it
     * with the indexer, and resetting the seeder with the incrementer until cc is full */
    char cc[CC_LEN];
    for (int i = 0; i < CC_LEN; i++) {
        char seedval[10];
        snprintf(seedval, 10, "%d", seed(seeder));
        cc[i] = seedval[indexer];
        seeder += incrementer;
    }

    /* read slice from the original input to compare (13 to 33) */
    c = 0;
    char our_cc[CC_LEN];
    while (c < CC_LEN) {
        our_cc[c] = input[c + 13];
        c++;
    }

    /* randomized index check for all the values that make up the target we want */
   if (our_cc[0] != cc[0]) exit(EXIT_FAILURE);
   if (our_cc[16] != cc[16]) exit(EXIT_FAILURE);
   if (our_cc[11] != cc[11]) exit(EXIT_FAILURE);
   if (our_cc[3] != cc[3]) exit(EXIT_FAILURE);
   if (our_cc[7] != cc[7]) exit(EXIT_FAILURE);
   if (our_cc[15] != cc[15]) exit(EXIT_FAILURE);
   if (our_cc[1] != cc[1]) exit(EXIT_FAILURE);
   if (our_cc[12] != cc[12]) exit(EXIT_FAILURE);
   if (our_cc[19] != cc[19]) exit(EXIT_FAILURE);
   if (our_cc[13] != cc[13]) exit(EXIT_FAILURE);
   if (our_cc[14] != cc[14]) exit(EXIT_FAILURE);
   if (our_cc[5] != cc[5]) exit(EXIT_FAILURE);
   if (our_cc[9] != cc[9]) exit(EXIT_FAILURE);
   if (our_cc[8] != cc[8]) exit(EXIT_FAILURE);
   if (our_cc[18] != cc[18]) exit(EXIT_FAILURE);
   if (our_cc[6] != cc[6]) exit(EXIT_FAILURE);
   if (our_cc[17] != cc[17]) exit(EXIT_FAILURE);
   if (our_cc[2] != cc[2]) exit(EXIT_FAILURE);
   if (our_cc[10] != cc[10]) exit(EXIT_FAILURE);
   if (our_cc[4] != cc[4]) exit(EXIT_FAILURE);

	/* check if we have a seperator after cc num */
    if (input[33] != ':') {
        printf("Get out.\n");
        exit(EXIT_FAILURE);
    }

	c = 0;
	char end[] = "end";
	while (c < 3) {
		if (end[c] != input[c + 34])
			exit(EXIT_FAILURE);
		c++;
	}

    /* return flag */
	printf("Thanks!\n");
    win();
    return 0;
}
